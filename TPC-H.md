# Example: NoLAP for TPC-H
The TPC Benchmark H (TPC-H) is a well-known and widely used decision support benchmark. It consists of a number of queries along with the data used to populate a database. We have taken some data generated by the TPC-H data generator (which is provided as a set of tables) and transformed it into the NoLAP multidimensional schema storing the data in a MongoDB database. The goal is purely educational to demonstrate how such a database could look like and what kind of reports and queries can be executed using JSONiq and the 28.io platform.

## Generic mapping from a SQL table to a hypercube
In order to convert the TPC benchmark data in a generic way (reproducible with other SQL tables), we associated each SQL table to a NoLAP static hypercube:
- Customers
- Suppliers
- SuppParts
- Orders
- LineItems
- (For the sake of simplicity, we excluded nations and regions that were "inlined" in customers and suppliers)

Then, for each table, the primary keys were converted to dimensions, and the other SQL attributes were converted to reportable concepts (primary items).

For example, consider the schema of the PARTSUPP table:

    PS_PARTKEY (primary)
    PS_SUPPKEY (primary)
    PS_AVAILQTY
    PS_SUPPLYCOST
    PS_COMMENT

This table can be mapped to a dimension-2 hypercube (dimensions: tpch:PartKey, tpch:SuppKey and the always present xbrl:Concept). Three concepts can be used: tpch:SupplierPartAvailableQuantity, tpch:SupplierPartSupplyCost, tpch:SupplierPartComment.

In XBRL, there are dimensions that are not technically required by NoLAP, but that are commonly there on a semantic level: xbrl:Entity, xbrl:Period and xbrl:Unit. In this case, tpch:SuppKey can be renamed to xbrl:Entity because a supplier can be considered an XBRL entity. xbrl:Period can be set with a dummy value ("forever"), and xbrl:Unit set according to the original SQL schema types. We are doing this because our implementation natively supports these four common xbrl: fields, but the only one that is important to the NoLAP mapping is xbrl:Concept.

Concretely, the following row (represented as flat JSON)

```json
{
  "PS_SUPPKEY" : "Supplier#000010000", 
  "PS_PARTKEY" : 1, 
  "PS_SUPPLYCOST" : 984.93, 
  "PS_AVAILQTY" : 1807, 
  "PS_COMMENT" : "egular requests sleep quickly across the regular theodolites. ironic ideas affix regular pains. blithely re"
}
```

can be mapped to the following facts:

    {
     Aspects: {
        "xbrl:Concept": "tpch:SupplierPartAvailableQuantity",
        "xbrl:Entity": "Supplier#0000100000",
        "xbrl:Period": "forever",
        "xbrl:Unit": "Numeric",
        "tpch:PartKey": 1
      },
      Value: 1807
    }
    {
      Aspects: {
        "xbrl:Concept": "tpch:SupplierPartSupplyCost",
        "xbrl:Entity": "Supplier#0000100000",
        "xbrl:Period": "forever",
        "xbrl:Unit": "USD",
        "tpch:PartKey": 1
      },
      Value: 984.93
    }
    {
      Aspects: {
        "xbrl:Concept": "tpch:SupplierPartComment",
        "xbrl:Entity": "Supplier#0000100000",
        "xbrl:Period": "forever",
        "tpch:PartKey": 1
      },
      Value: "egular requests sleep quickly across the regular theodolites. ironic ideas affix regular pains. blithely re"
    }

## Queries

Given the NoLAP schema described above, one can build plenty of useful queries.

### Custom Hypercube
For example, a user could define a custom hypercube (CustomerNation and CustomerName) on the set of facts and dicing the cube by picking specific values for some dimensions (CustomerNation is either PERU or GERMANY).

```xquery
for $fact in facts:facts-for({
    Filter: {
        "Profiles.TPC-H.tpch:Nation": [ "PERU", "GERMANY" ]
    },
    Hypercube: hypercubes:dimensionless-hypercube({
        Concepts: ["tpch:CustomerName"]
    })
})
order by $fact.Profiles."TPC-H"."tpch:Nation"
return {|
    $fact.Aspects,
	{ "tpch:Nation" : "Profiles.TPC-H.tpch:Nation" }
    { "tpch:CustomerName" : $fact.Value }
|}
```

This query returns a table of facts (aka as fact table) containing the names of all customers of PERU and GERMANY.
It is important to note, that such a query is very similar (and equally expressive) to an MDX query (MDX is a query language for OLAP databases).

### Static Hypercube

Components are metadata (living in the database) on top of facts.
Specifically, a component describes a hypercube.
For example, the components collection of the TPC-H database contains a hypercube that involves all possible concepts of customers (e.g. tpch:CustomerName, tpch:CustomerAddress, tpch:CustomerPhone, etc.).
Similarly to the custom hypercube query above, the hypercube of this component can be used to retrieve a dice of the cube.

```xquery
let $component := components:components()[$$.Role = "http://www.tpc.org/tpch/customers"]
let $hypercube := hypercubes:hypercubes-for-components($component)
for $fact in facts:facts-for({
    Filter: {
        "Profiles.TPC-H.tpch:Nation": [ "PERU", "GERMANY" ]
    },
    Hypercube: $hypercube
})
return {|
    $fact.Aspects,
    { Value : $fact.Value }
|}
```

This query returns all customer dimensions for the selected set of customers, i.e. the ones from Peru or Germany.

### Analytics using 28.io

Having the capability of dicing a customer hypercube, we can use JSONiq to build analytical queries such
as the following that is inspired by TPC-H Query 1.

```xquery
let $hypercube := hypercubes:user-defined-hypercube({
    "xbrl:Period": {
        Domain: [ "1996-01-02T00:00:00Z" ]
    },
    "tpch:LineNumber": {},
    "xbrl:Concept": {
        Domain: ["tpch:LineItemShipDate","tpch:LineItemReturnFlag","tpch:LineItemLineStatus",
                 "tpch:LineItemQuantity","tpch:LineItemExtendedPrice","tpch:LineItemDiscount","tpch:LineItemTax"]
    }
})
let $covered-aspects := ($facts:CONCEPT, $facts:UNIT)
let $lineitems :=
    for $facts in hypercubes:facts($hypercube)
    group by $canonical-filter-string := facts:canonically-serialize-object($facts.$facts:ASPECTS, $covered-aspects)
    return {
        linenumber: $facts[1]."tpch:LineNumber",
        shipdate: $facts[$$.$facts:ASPECTS.$facts:CONCEPT eq "tpch:LineItemShipDate"].Value,
        returnflag: $facts[$$.$facts:ASPECTS.$facts:CONCEPT eq "tpch:LineItemReturnFlag"].Value,
        linestatus: $facts[$$.$facts:ASPECTS.$facts:CONCEPT eq "tpch:LineItemLineStatus"].Value,
        quantity: $facts[$$.$facts:ASPECTS.$facts:CONCEPT eq "tpch:LineItemQuantity"].Value,
        extprice : $facts[$$.$facts:ASPECTS.$facts:CONCEPT eq "tpch:LineItemExtendedPrice"].Value,
        discount: $facts[$$.$facts:ASPECTS.$facts:CONCEPT eq "tpch:LineItemDiscount"].Value,
        tax :$facts[$$.$facts:ASPECTS.$facts:CONCEPT eq "tpch:LineItemTax"].Value
    }
for $lineitem in $lineitems
group by $returnflag := $lineitem.returnflag,
         $linestatus := $lineitem.linestatus
order by $returnflag, $linestatus
return {
    returnflag : $returnflag,
    linestatus : $linestatus,
    sum_qty : sum($lineitem.quantity),
    sum_base_price : sum($lineitem.extprice),
    sum_disc_price : sum($lineitem ! ($$.extprice * (1 - $$.discount))),
    sum_charge : sum($lineitem ! ($$.extprice * (1 - $$.discount) * (1 + $$.tax))),
    avg_qty : avg($lineitem.quantity),
    avg_extendedprice : avg($lineitem.extprice),
    avg_disc : avg($lineitem.discount),
    count_order : count($lineitem)
}
```

This query builds a customer hypercube including seven dimensions of line items.
Further, it filters the facts in this hypercube by fixing the period to "1996-01-02T00:00:00Z".
The resulting facts are then grouped as they belong together (i.e. having the primary key).
Those facts are then grouped by their values for tpch:LineItemReturnFlag and tpch:LineItemLineStatus.
The result is a set of JSON objects that contains aggregates (sum, avg, and count) for several
dimension values.
